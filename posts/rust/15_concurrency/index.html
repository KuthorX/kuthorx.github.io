<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Rust - Basic - 15 - Concurrency | KuthorX Blog II</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="RRRRRRRRRRRRRRR"><meta name=generator content="Hugo 0.148.2"><meta name=robots content="index, follow"><link rel=stylesheet href=/ananke/css/main.min.8d048772ae72ab11245a0e296d1f2a36d3e3dd376c6c867394d6cc659c68fc37.css><link rel=stylesheet href=/css/about.css><link rel="shortcut icon" href=/images/KuthorX-512.png type=image/x-icon><link rel=canonical href=https://kuthorx.github.io/posts/rust/15_concurrency/><meta property="og:url" content="https://kuthorx.github.io/posts/rust/15_concurrency/"><meta property="og:site_name" content="KuthorX Blog II"><meta property="og:title" content="Rust - Basic - 15 - Concurrency"><meta property="og:description" content="RRRRRRRRRRRRRRR"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-03T00:00:15+08:00"><meta property="article:modified_time" content="2022-01-03T00:00:15+08:00"><meta itemprop=name content="Rust - Basic - 15 - Concurrency"><meta itemprop=description content="RRRRRRRRRRRRRRR"><meta itemprop=datePublished content="2022-01-03T00:00:15+08:00"><meta itemprop=dateModified content="2022-01-03T00:00:15+08:00"><meta itemprop=wordCount content="645"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust - Basic - 15 - Concurrency"><meta name=twitter:description content="RRRRRRRRRRRRRRR"></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l center items-center justify-between"><a href=/ class="f3 fw2 hover-white white-90 dib no-underline">KuthorX Blog II</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/about/ title="About 页">About</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/posts/ title="Posts 页">Posts</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/repos/ title="Repos 页">Repos</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/story_of_cloak/ title="苍绿之眼 页">苍绿之眼</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/character/ title="角色 页">角色</a></li></ul><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l mw8 center ph3 flex-wrap justify-between"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Rust</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Rust - Basic - 15 - Concurrency</h1><time class="f6 mv4 dib tracked" datetime=2022-01-03T00:00:15+08:00>一月 3, 2022</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id=concurrency>Concurrency</h1><h1 id=comprehension>Comprehension</h1><p>实现并发/并行，可以使用 消息队列（Message-passing）或者 状态共享（Shared-state）实现</p><h2 id=thread>Thread</h2><p>并发需要注意以下几点</p><ul><li><p>数据竞争</p><p>Race conditions, where threads are accessing data or resources in an inconsistent order</p></li><li><p>死锁</p><p>Deadlocks, where two threads are waiting for each other to finish using a resource the other thread has, preventing both threads from continuing</p></li><li><p>难以复现的 BUG</p><p>Bugs that happen only in certain situations and are hard to reproduce and fix reliably</p></li></ul><p>Green Thread 是编程语言级别的 thread，和操作系统提供的 thread 功能不完全相同</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::thread;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::time::Duration;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> handle <span style=color:#f92672>=</span> thread::spawn(<span style=color:#f92672>||</span> {  <span style=color:#75715e>// 注意这里的闭包如果需要入参，需要显式声明 move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;hi number </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> from the spawned thread!&#34;</span>, i);
</span></span><span style=display:flex><span>            thread::sleep(Duration::from_millis(<span style=color:#ae81ff>1</span>));  <span style=color:#75715e>// 此时操作系统有机会切换执行其他线程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    handle.join().unwrap();  <span style=color:#75715e>// 使用 join 等待所有线程执行结束（否则后续代码不执行）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>5</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;hi number </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> from the main thread!&#34;</span>, i);
</span></span><span style=display:flex><span>        thread::sleep(Duration::from_millis(<span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=message-passing>Message-passing</h2><ul><li><p>Channel 基础写法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::sync::mpsc;  <span style=color:#75715e>// multiple producer single consumer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (tx, rx) <span style=color:#f92672>=</span> mpsc::channel();  <span style=color:#75715e>// transmitter, receiver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		thread::spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> val <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hi&#34;</span>);
</span></span><span style=display:flex><span>        tx.send(val).unwrap();  <span style=color:#75715e>// 此时 val moved ownership
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>let</span> received <span style=color:#f92672>=</span> rx.recv().unwrap();  <span style=color:#75715e>// 如果使用 try_recv 则不会阻塞
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Got: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, received);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>Multi producer/transmitter && Receive multi message</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::sync::mpsc;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::thread;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::time::Duration;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (tx, rx) <span style=color:#f92672>=</span> mpsc::channel();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 因为后续闭包内会 move tx 的 ownership
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 所以这里需要提前 clone 出 tx1 实现 multi producer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>let</span> tx1 <span style=color:#f92672>=</span> tx.clone();
</span></span><span style=display:flex><span>		thread::spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> vals <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[
</span></span><span style=display:flex><span>            String::from(<span style=color:#e6db74>&#34;hi&#34;</span>),
</span></span><span style=display:flex><span>            String::from(<span style=color:#e6db74>&#34;from&#34;</span>),
</span></span><span style=display:flex><span>            String::from(<span style=color:#e6db74>&#34;the&#34;</span>),
</span></span><span style=display:flex><span>            String::from(<span style=color:#e6db74>&#34;thread&#34;</span>),
</span></span><span style=display:flex><span>        ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> val <span style=color:#66d9ef>in</span> vals {
</span></span><span style=display:flex><span>            tx1.send(val).unwrap();
</span></span><span style=display:flex><span>            thread::sleep(Duration::from_secs(<span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    thread::spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> vals <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[
</span></span><span style=display:flex><span>            String::from(<span style=color:#e6db74>&#34;more&#34;</span>),
</span></span><span style=display:flex><span>            String::from(<span style=color:#e6db74>&#34;messages&#34;</span>),
</span></span><span style=display:flex><span>            String::from(<span style=color:#e6db74>&#34;for&#34;</span>),
</span></span><span style=display:flex><span>            String::from(<span style=color:#e6db74>&#34;you&#34;</span>),
</span></span><span style=display:flex><span>        ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> val <span style=color:#66d9ef>in</span> vals {
</span></span><span style=display:flex><span>            tx.send(val).unwrap();
</span></span><span style=display:flex><span>            thread::sleep(Duration::from_secs(<span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 注意较于上例，使用了 for-in loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> received <span style=color:#66d9ef>in</span> rx {  
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Got: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, received);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h2 id=shared-state>Shared-state</h2><p>Mutex（Mutual Exclusion，互斥现象），其中一个表现是：在同一时刻，只允许一个线程访问特定数据</p><p>线程必须获取 lock 才能访问 mutex 里的数据。lock 也在 mutex 的一部分，它可以持续跟踪谁对 mutex 里的数据有互斥访问权限。因此，互斥锁被描述为通过锁定系统保护其保持的数据。</p><p>基于以下两个规则，Mutexes 很难使用：</p><ul><li><p>在使用数据之前，必须试图获取锁</p><p>You must attempt to acquire the lock before using the data.</p></li><li><p>当 mutex 保护的数据使用完成时，必须释放锁，以让其他线程能获取锁</p><p>When you’re done with the data that the mutex guards, you must unlock the data so other threads can acquire the lock.</p></li></ul><p>管理 mutexex 很难做到，所以更多人喜欢用 channels 。不过，Rust 的 类型系统 和 所有权规则 保证了我们不会错误地获取、释放锁</p><ul><li><p>Mutex 基础写法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::sync::Mutex;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> m <span style=color:#f92672>=</span> Mutex::new(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> num <span style=color:#f92672>=</span> m.lock().unwrap();  <span style=color:#75715e>// 调用 lock 获取锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#f92672>*</span>num <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;m = </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, m);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Mutex&lt;T></code> 是一种智能指针；更精确地说，<code>lock</code> 返回 <code>LockResult</code>，此后的 <code>unwrap</code> 返回智能指针 <code>MutexGuard</code>；<code>MutexGuard</code> 实现了 <code>Deref</code> trait 以指向内部数据，还实现了 <code>Drop</code> trait 以在 <code>MutexGuard</code> 超出作用域时自动释放锁。因此，我们不会冒忘记释放锁和阻塞互斥锁被其他线程使用的风险，因为锁释放是自动发生的。</p></li><li><p>多线程共享 Mutex</p><p><strong>A</strong>tomic <strong>R</strong>eference <strong>C</strong>ounted Type，可以理解为带有 原子功能 的 <code>Rc&lt;T></code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::sync::{Arc, Mutex};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::thread;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> counter <span style=color:#f92672>=</span> Arc::new(Mutex::new(<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> handles <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> counter <span style=color:#f92672>=</span> Arc::clone(<span style=color:#f92672>&amp;</span>counter);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> handle <span style=color:#f92672>=</span> thread::spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> num <span style=color:#f92672>=</span> counter.lock().unwrap();
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>num <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        handles.push(handle);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> handle <span style=color:#66d9ef>in</span> handles {
</span></span><span style=display:flex><span>        handle.join().unwrap();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Result: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, <span style=color:#f92672>*</span>counter.lock().unwrap());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h2 id=send--sync-trait>Send & Sync trait</h2><p>实现了 <code>Send</code> trait 的类型，其 ownership 可以在线程间传递</p><p>实现了 <code>Sync</code> trait 的类型，其可以被多线程访问</p><p>可以看出，<code>Sync</code> 包含了 <code>Send</code> 的特性</p><h1 id=origin>Origin</h1><blockquote><p><a href=https://doc.rust-lang.org/book/ch16-00-concurrency.html>https://doc.rust-lang.org/book/ch16-00-concurrency.html</a></p></blockquote><p>&mldr;</p><h3 id=atomic-reference-counting-with><a href=https://doc.rust-lang.org/book/ch16-03-shared-state.html#atomic-reference-counting-with-arct>Atomic Reference Counting with <code>Arc&lt;T></code></a></h3><p>Fortunately, <code>Arc&lt;T></code> <em>is</em> a type like <code>Rc&lt;T></code> that is safe to use in concurrent situations. The <em>a</em> stands for <em>atomic</em>, meaning it’s an <em>atomically reference counted</em> type. Atomics are an additional kind of concurrency primitive that we won’t cover in detail here: see the standard library documentation for <code>[std::sync::atomic](https://doc.rust-lang.org/std/sync/atomic/index.html)</code> for more details. At this point, you just need to know that atomics work like primitive types but are safe to share across threads.</p><p>You might then wonder why all primitive types aren’t atomic and why standard library types aren’t implemented to use <code>Arc&lt;T></code> by default. The reason is that thread safety comes with a performance penalty that you only want to pay when you really need to. If you’re just performing operations on values within a single thread, your code can run faster if it doesn’t have to enforce the guarantees atomics provide.</p><p>Let’s return to our example: <code>Arc&lt;T></code> and <code>Rc&lt;T></code> have the same API, so we fix our program by changing the <code>use</code> line, the call to <code>new</code>, and the call to <code>clone</code>. The code in Listing 16-15 will finally compile and run:</p><p>&mldr;</p><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href=https://kuthorx.github.io/>&copy; KuthorX Blog II 2025</a><div><div class=ananke-socials></div></div></div></footer></body></html>
<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Rust - Basic - 12 - Iterators and Closures | KuthorX Blog II</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="RRRRRRRRRRRR"><meta name=generator content="Hugo 0.148.2"><meta name=robots content="index, follow"><link rel=stylesheet href=/ananke/css/main.min.8d048772ae72ab11245a0e296d1f2a36d3e3dd376c6c867394d6cc659c68fc37.css><link rel=stylesheet href=/css/about.css><link rel="shortcut icon" href=/images/KuthorX-512.webp type=image/x-icon><link rel=canonical href=https://kuthorx.github.io/posts/rust/12_iterators-and-closures/><meta property="og:url" content="https://kuthorx.github.io/posts/rust/12_iterators-and-closures/"><meta property="og:site_name" content="KuthorX Blog II"><meta property="og:title" content="Rust - Basic - 12 - Iterators and Closures"><meta property="og:description" content="RRRRRRRRRRRR"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-03T00:00:12+08:00"><meta property="article:modified_time" content="2022-01-03T00:00:12+08:00"><meta itemprop=name content="Rust - Basic - 12 - Iterators and Closures"><meta itemprop=description content="RRRRRRRRRRRR"><meta itemprop=datePublished content="2022-01-03T00:00:12+08:00"><meta itemprop=dateModified content="2022-01-03T00:00:12+08:00"><meta itemprop=wordCount content="1595"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust - Basic - 12 - Iterators and Closures"><meta name=twitter:description content="RRRRRRRRRRRR"></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l center items-center justify-between"><a href=/ class="f3 fw2 hover-white white-90 dib no-underline">KuthorX Blog II</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/about/ title="About 页">About</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/posts/ title="Posts 页">Posts</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/repos/ title="Repos 页">Repos</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/story_of_cloak/ title="苍绿之眼 页">苍绿之眼</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/character/ title="角色 页">角色</a></li></ul><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l mw8 center ph3 flex-wrap justify-between"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Rust</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Rust - Basic - 12 - Iterators and Closures</h1><time class="f6 mv4 dib tracked" datetime=2022-01-03T00:00:12+08:00>一月 3, 2022</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id=iterators-and-closures>Iterators and Closures</h1><blockquote><p>迭代器与闭包，函数式编程的思想之一</p></blockquote><h1 id=comprehension>Comprehension</h1><ul><li><p>closures</p><p>表现：函数可以被赋值为变量，此时函数未被调用</p><p>特点：不对调用者暴露、简短且意义明确</p><p>编译器会进行推断以决定使用哪种 Closures：</p><p><code>FnOnce</code> 当使用的外部环境被 taking ownership (move) 则使用</p><p><code>FnMut</code> 当使用的外部环境被 borrow mutably 则使用</p><p><code>Fn</code> 当使用的外部环境被 borrow immutably 则使用</p><p>环境即 <em>envrionment</em>，一般指闭包内使用的外部变量</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// 常见声明
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> expensive_closure <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>num<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;calculating slowly...&#34;</span>);
</span></span><span style=display:flex><span>    thread::sleep(Duration::from_secs(<span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    num
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 只有 a single expression 的时候
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> add_one_v3 <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>x<span style=color:#f92672>|</span>             { x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> };
</span></span><span style=display:flex><span><span style=color:#75715e>// 大括号可以去掉
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> add_one_v4 <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>x<span style=color:#f92672>|</span>               x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>  ;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// closures 自带 type inferred
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> example_closure <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>x<span style=color:#f92672>|</span> x;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> s <span style=color:#f92672>=</span> example_closure(String::from(<span style=color:#e6db74>&#34;hello&#34;</span>));
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> n <span style=color:#f92672>=</span> example_closure(<span style=color:#ae81ff>5</span>);  <span style=color:#75715e>// 编译器处理到这里的时候会报错
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用 struct + closures + trait 实现 lazy load
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Cacher</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    T: Fn(<span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    calculation: <span style=color:#a6e22e>T</span>,
</span></span><span style=display:flex><span>    value: Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Cacher<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    T: Fn(<span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(calculation: <span style=color:#a6e22e>T</span>) -&gt; <span style=color:#a6e22e>Cacher</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        Cacher {
</span></span><span style=display:flex><span>            calculation,
</span></span><span style=display:flex><span>            value: None,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>value</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, arg: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>u32</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self.value {
</span></span><span style=display:flex><span>            Some(v) <span style=color:#f92672>=&gt;</span> v,
</span></span><span style=display:flex><span>            None <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> v <span style=color:#f92672>=</span> (self.calculation)(arg);
</span></span><span style=display:flex><span>                self.value <span style=color:#f92672>=</span> Some(v);
</span></span><span style=display:flex><span>                v
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 通过 move 关键字强制指定
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 一般不会这么做（交给编译器推导）
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 以下代码无法通过编译（因为 x 被 move 了）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> equal_to_x <span style=color:#f92672>=</span> <span style=color:#66d9ef>move</span> <span style=color:#f92672>|</span>z<span style=color:#f92672>|</span> z <span style=color:#f92672>==</span> x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;can&#39;t use x here: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert!</span>(equal_to_x(y));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>iterators</p><p>迭代 和 循环 性能没有差别。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// 基础写法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>iterator_demonstration</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> v1 <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 由于后续需要 next，会修改 v1 迭代器状态，故需要 mut 关键字
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 如果需要 take ownership，则使用 into_iter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// 如果需要 mutable referance，则使用 iter_mut
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> v1_iter <span style=color:#f92672>=</span> v1.iter();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(v1_iter.next(), Some(<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(v1_iter.next(), Some(<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(v1_iter.next(), Some(<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>3</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(v1_iter.next(), None);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> v1: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span><span style=color:#75715e>// 这里没有 consuming adaptors（调用 next 的 methods）会触发 compile warning
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>v1.iter().map(<span style=color:#f92672>|</span>x<span style=color:#f92672>|</span> x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> v2: Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> v1.iter().map(<span style=color:#f92672>|</span>x<span style=color:#f92672>|</span> x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>).collect(); <span style=color:#75715e>// 使用 collect 消费迭代器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>assert_eq!</span>(v2, <span style=color:#a6e22e>vec!</span>[<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// into_inter 使用示例 - filter
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>#[derive(PartialEq, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Shoe</span> {
</span></span><span style=display:flex><span>    size: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    style: String,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>shoes_in_size</span>(shoes: Vec<span style=color:#f92672>&lt;</span>Shoe<span style=color:#f92672>&gt;</span>, shoe_size: <span style=color:#66d9ef>u32</span>) -&gt; Vec<span style=color:#f92672>&lt;</span>Shoe<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    shoes.into_iter().filter(<span style=color:#f92672>|</span>s<span style=color:#f92672>|</span> s.size <span style=color:#f92672>==</span> shoe_size).collect()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 实现一个能 iter 的 struct
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Counter</span> {
</span></span><span style=display:flex><span>    count: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Counter {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Counter</span> {
</span></span><span style=display:flex><span>        Counter { count: <span style=color:#ae81ff>0</span> }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Iterator <span style=color:#66d9ef>for</span> Counter {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>u32</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self.count <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span> {
</span></span><span style=display:flex><span>            self.count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            Some(self.count)
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            None
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>calling_next_directly</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> counter <span style=color:#f92672>=</span> Counter::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(counter.next(), Some(<span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(counter.next(), Some(<span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(counter.next(), Some(<span style=color:#ae81ff>3</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(counter.next(), Some(<span style=color:#ae81ff>4</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(counter.next(), Some(<span style=color:#ae81ff>5</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(counter.next(), None);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用其它 Iterator Trait Methods
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>using_other_iterator_trait_methods</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> sum: <span style=color:#66d9ef>u32</span> <span style=color:#f92672>=</span> Counter::new()
</span></span><span style=display:flex><span>        .zip(Counter::new().skip(<span style=color:#ae81ff>1</span>))  <span style=color:#75715e>// 任一 iter 返回 None，zip 停止 pair items，所以这里只有 4 pairs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        .map(<span style=color:#f92672>|</span>(a, b)<span style=color:#f92672>|</span> a <span style=color:#f92672>*</span> b)
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|</span>x<span style=color:#f92672>|</span> x <span style=color:#f92672>%</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        .sum();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(<span style=color:#ae81ff>18</span>, sum);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h1 id=origin>Origin</h1><blockquote><p><a href=https://doc.rust-lang.org/book/ch13-00-functional-features.html>https://doc.rust-lang.org/book/ch13-00-functional-features.html</a></p></blockquote><p>&mldr;</p><h3 id=closure-type-inference-and-annotation><a href=https://doc.rust-lang.org/book/ch13-01-closures.html#closure-type-inference-and-annotation>Closure Type Inference and Annotation</a></h3><p>Closures don’t require you to annotate the types of the parameters or the return value like <code>fn</code> functions do. Type annotations are required on functions because they’re part of an explicit interface exposed to your users. Defining this interface rigidly is important for ensuring that everyone agrees on what types of values a function uses and returns. But closures aren’t used in an exposed interface like this: they’re <strong>stored in variables and used without naming them and exposing them to users of our library</strong>.</p><p>Closures are usually <strong>short and relevant</strong> only within a narrow context rather than in any arbitrary scenario. Within these limited contexts, the compiler is reliably able to infer the types of the parameters and the return type, similar to how it’s able to infer the types of most variables.</p><p>Making programmers annotate the types in these small, anonymous functions would be annoying and largely redundant with the information the compiler already has available.</p><p>&mldr;</p><h3 id=capturing-the-environment-with-closures><a href=https://doc.rust-lang.org/book/ch13-01-closures.html#capturing-the-environment-with-closures>Capturing the Environment with Closures</a></h3><p>In the workout generator example, we only used closures as inline anonymous functions. However, closures have an additional capability that functions don’t have: they can capture their environment and access variables from the scope in which they’re defined.</p><p>Listing 13-12 has an example of a closure stored in the <code>equal_to_x</code> variable that uses the <code>x</code> variable from the closure’s surrounding environment.</p><p>Filename: src/main.rs</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> equal_to_x <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>z<span style=color:#f92672>|</span> z <span style=color:#f92672>==</span> x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert!</span>(equal_to_x(y));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Listing 13-12: Example of a closure that refers to a variable in its enclosing scope</strong></p><p>Here, even though <code>x</code> is not one of the parameters of <code>equal_to_x</code>, the <code>equal_to_x</code> closure is allowed to use the <code>x</code> variable that’s defined in the same scope that <code>equal_to_x</code> is defined in.</p><p>We can’t do the same with functions; if we try with the following example, our code won’t compile:</p><p>Filename: src/main.rs</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>equal_to_x</span>(z: <span style=color:#66d9ef>i32</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        z <span style=color:#f92672>==</span> x
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert!</span>(equal_to_x(y));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We get an error:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo run
</span></span><span style=display:flex><span>   Compiling equal-to-x v0.1.0 <span style=color:#f92672>(</span>file:///projects/equal-to-x<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>error<span style=color:#f92672>[</span>E0434<span style=color:#f92672>]</span>: can<span style=color:#960050;background-color:#1e0010>&#39;</span>t capture dynamic environment in a fn item
</span></span><span style=display:flex><span> --&gt; src/main.rs:5:14
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span><span style=color:#ae81ff>5</span> |         z <span style=color:#f92672>==</span> x
</span></span><span style=display:flex><span>  |              ^
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span>  <span style=color:#f92672>=</span> help: use the <span style=color:#e6db74>`</span><span style=color:#f92672>||</span> <span style=color:#f92672>{</span> ... <span style=color:#f92672>}</span><span style=color:#e6db74>`</span> closure form instead
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>For more information about this error, try <span style=color:#e6db74>`</span>rustc --explain E0434<span style=color:#e6db74>`</span>.
</span></span><span style=display:flex><span>error: could not compile <span style=color:#e6db74>`</span>equal-to-x<span style=color:#e6db74>`</span> due to previous error
</span></span></code></pre></div><p>The compiler even reminds us that this only works with closures!</p><p>When a closure captures a value from its environment, it uses memory to store the values for use in the closure body. This use of memory is overhead that we don’t want to pay in more common cases where we want to execute code that doesn’t capture its environment. Because functions are never allowed to capture their environment, defining and using functions will never incur this overhead.</p><p>Closures can capture values from their environment in three ways, which directly map to the three ways a function can take a parameter: <strong>taking ownership, borrowing mutably, and borrowing immutably</strong>. These are encoded in the three <code>Fn</code> traits as follows:</p><ul><li><code>FnOnce</code> consumes the variables it captures from its enclosing scope, known as the closure’s <em>environment</em>. To consume the captured variables, the closure must take ownership of these variables and move them into the closure when it is defined. The <code>Once</code> part of the name represents the fact that the closure can’t take ownership of the same variables more than once, so it can be called only once.</li><li><code>FnMut</code> can change the environment because it mutably borrows values.</li><li><code>Fn</code> borrows values from the environment immutably.</li></ul><p>When you create a closure, Rust infers which trait to use based on how the closure uses the values from the environment. All closures implement <code>FnOnce</code> because they can all be called at least once. Closures that don’t move the captured variables also implement <code>FnMut</code>, and closures that don’t need mutable access to the captured variables also implement <code>Fn</code>. In Listing 13-12, the <code>equal_to_x</code> closure borrows <code>x</code> immutably (so <code>equal_to_x</code> has the <code>Fn</code> trait) because the body of the closure only needs to read the value in <code>x</code>.</p><p>When you create a closure, Rust infers which trait to use based on how the closure uses the values from the environment. All closures implement <code>FnOnce</code> because they can all be called at least once. Closures that don’t move the captured variables also implement <code>FnMut</code>, and closures that don’t need mutable access to the captured variables also implement <code>Fn</code>. In Listing 13-12, the <code>equal_to_x</code> closure borrows <code>x</code> immutably (so <code>equal_to_x</code> has the <code>Fn</code> trait) because the body of the closure only needs to read the value in <code>x</code>.</p><p>If you want to force the closure to take ownership of the values it uses in the environment, you can use the <code>move</code> keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so it’s owned by the new thread.</p><blockquote><p>Note: move closures may still implement Fn or FnMut, even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them. The move keyword only specifies the latter.</p></blockquote><p>We’ll have more examples of <code>move</code> closures in Chapter 16 when we talk about concurrency. For now, here’s the code from Listing 13-12 with the <code>move</code> keyword added to the closure definition and using vectors instead of integers, because integers can be copied rather than moved; note that this code will not yet compile.</p><p>Filename: src/main.rs</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> equal_to_x <span style=color:#f92672>=</span> <span style=color:#66d9ef>move</span> <span style=color:#f92672>|</span>z<span style=color:#f92672>|</span> z <span style=color:#f92672>==</span> x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;can&#39;t use x here: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert!</span>(equal_to_x(y));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We receive the following error:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo run
</span></span><span style=display:flex><span>   Compiling equal-to-x v0.1.0 <span style=color:#f92672>(</span>file:///projects/equal-to-x<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>error<span style=color:#f92672>[</span>E0382<span style=color:#f92672>]</span>: borrow of moved value: <span style=color:#e6db74>`</span>x<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span> --&gt; src/main.rs:6:40
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span> |     let x <span style=color:#f92672>=</span> vec!<span style=color:#f92672>[</span>1, 2, 3<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>  |         - move occurs because <span style=color:#e6db74>`</span>x<span style=color:#e6db74>`</span> has type <span style=color:#e6db74>`</span>Vec&lt;i32&gt;<span style=color:#e6db74>`</span>, which does not implement the <span style=color:#e6db74>`</span>Copy<span style=color:#e6db74>`</span> trait
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span> |
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span> |     let equal_to_x <span style=color:#f92672>=</span> move |z| z <span style=color:#f92672>==</span> x;
</span></span><span style=display:flex><span>  |                      --------      - variable moved due to use in closure
</span></span><span style=display:flex><span>  |                      |
</span></span><span style=display:flex><span>  |                      value moved into closure here
</span></span><span style=display:flex><span><span style=color:#ae81ff>5</span> |
</span></span><span style=display:flex><span><span style=color:#ae81ff>6</span> |     println!<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;can&#39;t use x here: {:?}&#34;</span>, x<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  |                                        ^ value borrowed here after move
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>For more information about this error, try <span style=color:#e6db74>`</span>rustc --explain E0382<span style=color:#e6db74>`</span>.
</span></span><span style=display:flex><span>error: could not compile <span style=color:#e6db74>`</span>equal-to-x<span style=color:#e6db74>`</span> due to previous error
</span></span></code></pre></div><p>The <code>x</code> value is moved into the closure when the closure is defined, because we added the <code>move</code> keyword. The closure then has ownership of <code>x</code>, and <code>main</code> isn’t allowed to use <code>x</code> anymore in the <code>println!</code> statement. Removing <code>println!</code> will fix this example.</p><p>Most of the time when specifying one of the <code>Fn</code> trait bounds, you can start with <code>Fn</code> and the compiler will tell you if you need <code>FnMut</code> or <code>FnOnce</code> based on what happens in the closure body.</p><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href=https://kuthorx.github.io/>&copy; KuthorX Blog II 2025</a><div><div class=ananke-socials></div></div></div></footer></body></html>